/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <string>
#include <fstream>
#include <iostream>
#include <vector>
#include <map>
#include <list>

#include <stdlib.h>
#include <sys/stat.h>
#include <sstream>
#include "t_generator.h"
#include "platform.h"

using std::map;
using std::ofstream;
using std::ostringstream;
using std::pair;
using std::string;
using std::stringstream;
using std::vector;

static const string endl = "\n";  // avoid ostream << std::endl flushes

/**
 * Scala code generator
 */
class t_scala_generator : public t_generator {
  public:
    t_scala_generator(
        t_program* program,
        const std::map<std::string, std::string>& parsed_options,
        const std::string& option_string)
      : t_generator(program)
    {
      (void) parsed_options;
      (void) option_string;
      out_dir_base_ = "gen-scala";
    }

    /**
     * Init and end of generator
     */
    void init_generator();
    void close_generator();

    /**
     * Program-level generation functions
     */
    void generate_typedef (t_typedef*  ttypedef);
    void generate_enum    (t_enum*     tenum);
    void generate_const   (t_const*    tconst);
    void generate_struct  (t_struct*   tstruct);
    void generate_service (t_service*  tservice);

  protected:
    void generate_scala_struct  (t_struct* tstruct);
    void generate_scala_union   (t_struct* tunion);
    void generate_scala_xception(t_struct* xception);
  
    /**
     * Helpers
     */
    std::string get_header      ();
    std::string base_type_name  (t_base_type* tbase);
    std::string type_name       (t_type* ttype);
    std::string get_value       (t_type* type, t_const_value* value);

  private:
    std::ofstream package_file_;
    std::string package_name_;
    std::string package_dir_;
};

void t_scala_generator::init_generator() {
  // Make output directory
  MKDIR(get_out_dir().c_str());
  package_name_ = program_->get_namespace("java");

  string dir = package_name_;
  string subdir = get_out_dir();
  string::size_type loc;
  while ((loc = dir.find(".")) != string::npos) {
    subdir = subdir + "/" + dir.substr(0, loc);
    MKDIR(subdir.c_str());
    dir = dir.substr(loc+1);
  }
  if (dir.size() > 0) {
    subdir = subdir + "/" + dir;
    MKDIR(subdir.c_str());
  }
  
  string package_file_name = subdir + "/" + dir + ".scala";
  package_file_.open(package_file_name.c_str());
  package_file_ << get_header() 
                << "package " << package_name_ << endl
                << endl;
  package_dir_ = subdir;
}

void t_scala_generator::close_generator() {
  package_file_.close();
}

void t_scala_generator::generate_typedef (t_typedef* ttypedef) {
  indent(package_file_) << "type " << ttypedef->get_symbolic() << " = " << type_name(ttypedef->get_type()) << endl;
}

std::string t_scala_generator::get_header() {
  return "/*\n * Autogenerated by Thrift Compiler\n */\n";
}

void t_scala_generator::generate_enum (t_enum* tenum) {
  string name = tenum->get_name();

  vector<t_enum_value*> values = tenum->get_constants();
  vector<t_enum_value*>::iterator val_iter;
  for (val_iter = values.begin(); val_iter != values.end(); ++val_iter) {
  }

}

void t_scala_generator::generate_const (t_const* tconst) {
  string name = tconst->get_name();
  package_file_ << "val " << name << ": " << type_name(tconst->get_type()) << " = " << get_value(tconst->get_type(), tconst->get_value()) << endl;
}

void t_scala_generator::generate_struct  (t_struct*   tstruct) {
  string name = tstruct->get_name();

  if (tstruct->is_xception()) {
    generate_scala_xception(tstruct);
  } else if (tstruct->is_union()) {
    generate_scala_union(tstruct);
  } else {
    generate_scala_struct(tstruct);
  }
}

void t_scala_generator::generate_service (t_service*  tservice) {
  string service_name = get_service_name(tservice);
  vector<t_function*> functions = tservice->get_functions();
  vector<t_function*>::iterator fn_iter = functions.begin();
  for ( ; fn_iter != functions.end(); fn_iter++) {
    string fn_name = (*fn_iter)->get_name();

    vector<t_field*> args = (*fn_iter)->get_arglist()->get_members();
    vector<t_field*>::iterator arg_iter = args.begin();
    for ( ; arg_iter != args.end(); arg_iter++) {
      if ((*arg_iter)->get_value() != NULL) {
      }
    }
    // end of node
  }
}

void t_scala_generator::generate_scala_struct(t_struct* tstruct) {

}

void t_scala_generator::generate_scala_union(t_struct* tunion) {

}

void t_scala_generator::generate_scala_xception(t_struct* xception) {

}

std::string t_scala_generator::base_type_name(t_base_type* tbase) {
  switch (tbase->get_base()) {
  case t_base_type::TYPE_VOID:
    return "Unit";
  case t_base_type::TYPE_STRING:
    if (tbase->is_binary()) {
      return "ByteBuffer";
    } else {
      return "String";
    }
  case t_base_type::TYPE_BOOL:
    return "Bool";
  case t_base_type::TYPE_BYTE:
    return "Byte";
  case t_base_type::TYPE_I16:
    return "Short";
  case t_base_type::TYPE_I32:
    return "Int";
  case t_base_type::TYPE_I64:
    return "Long";
  case t_base_type::TYPE_DOUBLE:
    return "Double";
  default:
    throw "compiler error: no Scala name for base type " + tbase->get_name();
  }
}

std::string t_scala_generator::type_name(t_type* ttype) {
  while (ttype->is_typedef()) {
    ttype = ((t_typedef*)ttype)->get_type();
  }

  if (ttype->is_base_type()) {
    return base_type_name((t_base_type*)ttype);
  } else if (ttype->is_map()) {
    t_map *tmap = (t_map*) ttype;
    return "Map[" + type_name(tmap->get_key_type()) +
      ", " + type_name(tmap->get_val_type()) + "]";
  } else if (ttype->is_set()) {
    t_set* tset = (t_set*) ttype;
    return "Set[" + type_name(tset->get_elem_type()) + "]";
  } else if (ttype->is_list()) {
    t_list* tlist = (t_list*) ttype;
    return "List[" + type_name(tlist->get_elem_type()) + "]";
  }

  t_program* program = ttype->get_program();
  if (program != NULL && program != program_) {
    string ns = program->get_namespace("java");
    if (!ns.empty()) {
      return ns + "." + ttype->get_name();
    }
  }

  return ttype->get_name();
}

std::string t_scala_generator::get_value(t_type* type, t_const_value* value) {
  std::ostringstream render;

  if (type->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_STRING:
      render << '"' << value->get_string() << '"';
      break;
    case t_base_type::TYPE_BOOL:
      render << ((value->get_integer() > 0) ? "true" : "false");
      break;
    case t_base_type::TYPE_BYTE:
    case t_base_type::TYPE_I16:
    case t_base_type::TYPE_I32:
    case t_base_type::TYPE_I64:
      render << value->get_integer();
      break;
    case t_base_type::TYPE_DOUBLE:
      if (value->get_type() == t_const_value::CV_INTEGER) {
        render << value->get_integer();
      } else {
        render << value->get_double();
      }
      break;
    default:
      throw "compiler error: no const of base type " + type->get_name();
    }
  } else if (type->is_enum()) {
    render << type->get_name() << "." << value->get_identifier_name();
  } else {
    render << "";
  }

  return render.str();
}

THRIFT_REGISTER_GENERATOR(scala, "Scala", "")

